unit uTBase64;

interface

uses sysUtils,Classes;


type TBase64 = class(TComponent)
     private
      ffilterdecodeinput:boolean;
      FHakkinda: string;
      function ValueToCharacter(value:Byte;var character:char):boolean;
      function CharacterToValue(character:char;var value:byte):boolean;
      function filterLine(InputData:string):string;
      procedure SetHakkinda(Val: string);
     protected
     public
      function EncodeData(InputData:string;var OutputData:string):Byte;
      function DecodeData(InputData:string;var OutputData:string):Byte;
      constructor Create(AOwner: TComponent); override;
     published
      property filterdecodeinput:boolean read ffilterdecodeinput write ffilterdecodeinput;
      property Hakkinda: string read FHakkinda write SetHakkinda;
     end;

     procedure Register;

const BASE64_OK       = 0; // hatasýz tamamlandý.
      BASE64_ERROR    = 1; // bilinmeyen hata.
      BASE64_INVALID  = 2; // geçersiz karakter
      BASE64_LENGTH   = 3; // girilen deðer base64 için çok büyük
      BASE64_DATALEFT = 4;
      BASE64_PADDING  = 5;


implementation


const AlphabetLength = 64;
      Alphabet:string[AlphabetLength]='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      Pad = '=';

procedure Register;
begin
  RegisterComponents('Tech', [TBase64]);
end;

procedure TBase64.SetHakkinda(Val: string);
begin
        { Kayýt giriþi yapýlamaz...}
end;

constructor TBase64.Create(AOwner: TComponent);
begin
 inherited Create(AOwner);
 ffilterdecodeinput:=true;
 FHakkinda := 'Copyright by TechnoLIFE /by Serkan';
end;


function TBase64.ValueToCharacter(value:Byte;var character:char):boolean;
begin
 Result:=true;
 if (value>AlphabetLength-1) then Result:=false
                             else character:=Alphabet[value+1];
end;


function TBase64.CharacterToValue(character:char;var value:byte):boolean;
begin
 Result:=true;
 value:=Pos(character,Alphabet);
 if value=0 then Result:=false
            else value:=value-1;
end;

function TBase64.EncodeData(InputData:string;var OutputData:string):Byte;
var i:integer;
    currentb,prevb:Byte;
    c:Byte;
    s:char;
    InputLength:integer;

begin
 OutPutData:='';
 InputLength:=Length(InputData);
 i:=1;
 if (InputLength=0) then begin Result:=BASE64_OK;exit;end;

 repeat

  currentb:=ord(InputData[i]);
  i:=i+1;
  InputLength:=InputLength-1;
  c:=(currentb shr 2);
  if not ValueToCharacter(c,s) then begin Result:=BASE64_ERROR;exit;end;
  OutPutData:=OutPutData+s;
  prevb:=currentb;


  if InputLength=0 then currentb:=0
              else begin
                    currentb:=ord(InputData[i]);
                    i:=i+1;
                   end;
  InputLength:=InputLength-1;
  c:=(prevb and $03) shl 4 + (currentb shr 4);
  if not ValueToCharacter(c,s) then begin Result:=BASE64_ERROR;exit;end;
  OutPutData:=OutPutData+s;
  prevb:=currentb;


  if InputLength<0 then s:=pad
                   else
   begin
    if InputLength=0 then currentb:=0
              else begin
                    currentb:=ord(InputData[i]);
                    i:=i+1;
                   end;
    InputLength:=InputLength-1;
    c:=(prevb and $0F) shl 2 + (currentb shr 6);
    if not ValueToCharacter(c,s) then begin Result:=BASE64_ERROR;exit;end;
   end;
  OutPutData:=OutPutData+s;

  if InputLength<0 then s:=pad
                    else
                    begin
                     c:=(currentb and $3F);
                     if not ValueToCharacter(c,s) then begin Result:=BASE64_ERROR;exit;end;
                    end;
  OutPutData:=OutPutData+s;

 until InputLength<=0;

 result:=BASE64_OK;
end;


function TBase64.filterLine(InputData:string):string;
var f:byte;
    i:integer;
begin
   result:='';
   for i:= 1 to Length(InputData) do
    if CharacterToValue(inputData[i],f) or (InputData[i]=Pad) then result:=Result+InputData[i];
end;

function TBase64.DecodeData(InputData:string;var OutputData:string):Byte;
var i:integer;
    InputLength:integer;
    currentb,prevb:Byte;
    c:Byte;
    s:char;

begin
 if (InputData='') then begin result:=BASE64_OK;exit;end;
 OutPutData:='';

 if filterdecodeinput then InputData:=FilterLine(InputData);

 InputLength:=Length(InputData);
 if InputLength mod 4<>0 then begin Result:=BASE64_LENGTH;exit;end;

 i:=0;
 repeat
    // process first byte
    i:=i+1;s:=InputData[i];  if not CharacterToValue(s,currentb) then begin Result:=BASE64_INVALID;exit;end;
    i:=i+1;s:=InputData[i];  if not CharacterToValue(s,prevb)    then begin Result:=BASE64_INVALID;exit;end;

    c:=(currentb shl 2)+(prevb shr 4);
    OutPutData:=OutPutData+chr(c);

    // process second Byte
    i:=i+1;s:=InputData[i];
    if s=pad then
      begin
       if (i<>InputLength-1) then begin Result:=BASE64_DATALEFT;exit;end // too much data left
                                  else if InputData[i+1]<>pad then begin Result:=BASE64_PADDING;exit;end; // last char has to be a pad
      end
      else
      begin
       if not CharacterToValue(s,currentb) then begin Result:=BASE64_INVALID;exit;end;
       c:=(prevb shl 4)+(currentb shr 2);
       OutPutData:=OutPutData+chr(c);
      end;

    // process third Byte
   i:=i+1;s:=InputData[i];
   if s=pad then
    begin
     if (i<>InputLength) then begin Result:=BASE64_DATALEFT;exit;end; // too much data Left
    end
    else
    begin
     if not CharacterToValue(s,prevb) then begin Result:=BASE64_INVALID;exit;end;
     c:=(currentb shl 6)+(prevb);
     OutPutData:=OutPutData+chr(c);
    end;

 until (i>=InputLength);
 result:=BASE64_OK;
end;

end.
